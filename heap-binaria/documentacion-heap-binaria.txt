Para realizar la cola de prioridades que maneje  la gestion los combates en un torneo, hemos decidido implementar una Heap Binaria utilizando la Bibloteca "heapq" en Python, que internamente maneja un min-heap invertido.

Python no incluye una implementaci칩n directa de un max-heap en su biblioteca est치ndar, por ello, al inve


쯇or que hemos decidido utilizar esta libreria y no implementar una Max-heap manualmente?

Eficiencia y Optimizaci칩n:
Optimizacion de heapq: La implementaci칩n de heapq est치 escrita en C y es parte de la biblioteca est치ndar de Python, lo que significa que est치 muy bien optimizada en t칠rminos de rendimiento.
Operaciones en 洧녝(log 洧녵): Las operaciones de inserci칩n (heappush) y extracci칩n del m칤nimo (heappop) est치n implementadas de manera eficiente con una complejidad de tiempo de 洧녝(log 洧녵) , lo cual es ideal para manejar grandes cantidades de datos.
Eficiencia de los metodos:
heapq.heappush: O(log n).
heapq.heappop: O(log n).
Verificar si est치 vac칤a: O(1).

Simplicidad de Uso:
Mucho menos c칩digo: Usar heapq te ahorra tener que escribir y depurar el c칩digo de un heap binario implementado desde cero. La librer칤a te proporciona funciones que hacen todo el trabajo de forma sencilla, como heappush, heappop, heapify, etc.

Mantenimiento y Robustez:
C칩digo confiable: La implementaci칩n de heapq ha sido ampliamente probada y es parte de la biblioteca est치ndar de Python. Esto significa que tiene menos probabilidades de tener errores en comparaci칩n con una implementaci칩n manual.
Compatibilidad futura: Si Python hace mejoras en el c칩digo de heapq en futuras versiones, automaticamente las recibimos en nuestro codigo.

A modo de instacia de aprendizaje, hemos indagado en la estructura de una max-heap, para conocer su implementacion manual desde cero, para cuando tengamos que leer codigo en otro lenguaje que no posea este nivel de abstraccion con las librerias.

class MaxHeap:
    def __init__(self):
        self.heap = []

    def __len__(self):
        return len(self.heap)

    def padre(self, i):
        return (i - 1) // 2

    def hijo_izquierdo(self, i):
        return 2 * i + 1

    def hijo_derecho(self, i):
        return 2 * i + 2

    def insertar(self, valor):
        #Agrega un valor al heap y restaura la propiedad de max-heap.
        self.heap.append(valor)  # Agregar al final
        self.heapify_up(len(self.heap) - 1)  # Reubicar hacia arriba

    def extraer_maximo(self):
        #Extrae y devuelve el m치ximo del heap.
        if not self.heap:
            return None  # El heap est치 vac칤o
        
        maximo = self.heap[0]  # El m치ximo es la ra칤z
        ultimo = self.heap.pop()  # Elimina el 칰ltimo elemento

        if self.heap:  # Si no est치 vac칤o despu칠s de la extracci칩n
            self.heap[0] = ultimo  # Mueve el 칰ltimo elemento a la ra칤z
            self.heapify_down(0)  # Reubica hacia abajo

        return maximo

    def heapify_up(self, i):
        #Reubica el elemento hacia arriba para mantener la propiedad de max-heap.
        while i > 0:
            padre = self.padre(i)
            if self.heap[i] > self.heap[padre]:  # Si el hijo es mayor que el padre
                self.heap[i], self.heap[padre] = self.heap[padre], self.heap[i]  # Intercambia
                i = padre  # Continua desde el nuevo 칤ndice
            else:
                break

    def heapify_down(self, i):
        #Reubica el elemento hacia abajo para mantener la propiedad de max-heap.
        while True:
            izq = self.hijo_izquierdo(i)
            der = self.hijo_derecho(i)
            mayor = i

            # Compara con el hijo izquierdo
            if izq < len(self.heap) and self.heap[izq] > self.heap[mayor]:
                mayor = izq

            # Compara con el hijo derecho
            if der < len(self.heap) and self.heap[der] > self.heap[mayor]:
                mayor = der

            if mayor == i:  # Si no hay cambios, terminamos
                break

            # Intercambia con el hijo mayor
            self.heap[i], self.heap[mayor] = self.heap[mayor], self.heap[i]
            i = mayor  # Continua desde el nuevo 칤ndice

    def mostrar_heap(self):
        #Muestra el heap actual (para depuraci칩n).
        print(self.heap)








Paginas o fuentes consultadas: 
Oficial:
https://docs.python.org/es/3.13/library/heapq.html

informal:
https://stackoverflow.com/questions/12356564/looking-for-an-inverted-heap-in-python
